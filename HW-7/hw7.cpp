/* *
* (A database used to store information about room names and amount of rooms needed, along with the ability to change the library type)
*
* Completion time : 8.5 hours
*
* @author Kipchun (AJH)
* @version: 11/11/2024
* @ide: Jetbrains Rider (2024.2.7)
* @compiler: MSVC
*/


// READ BEFORE YOU START:
// You are given a partially completed program that creates a list of rooms.
// Each room has name, number of rooms and library type (hayden or noble).
// This information is stored as an object of Room class. Class defined in room.h
// The classes Hayden and Noble are child classes of the Room class.
// When adding a new room, these child classes are used to make the room node of the list.
// So each node in the list is actually an object of either Hayden or Noble class.

//
// To begin, you should trace through the given code and understand how it works.
// Please read the instructions above each required function and follow the directions carefully.
// Do not modify given code.

// You can assume that all input is valid:
// Valid name:	String containing alphabetical letters
// Valid number: a positive integer

#include <iostream>
#include <fstream>
#include <string>
#include "Container.h"
#include "room.h"
#include "noble.h"
#include "hayden.h"

using namespace std;

// functions already implemented:
void executeAction(char c);
Room* searchRoom(string name_input);


// functions that need implementation:
void addRoom(string name_input, int no_input, libraryType type);			// 7 points
void displayList();							// 4 points
void save(string fileName);					// 7 points
void load(string fileName);					// 7 points

Container* list = NULL;				// global list

int main()
{
	char c = 'i';				// initialized to a dummy value

  // During first execution, there will be no list.txt in source directory. list.txt is generated by save() while exiting the program.
	load("list.txt");			
	do {
		cout << "\nCSE240 HW7\n";
		cout << "Please enter your selection:\n";
		cout << "\t a: add a new room\n";
		cout << "\t d: display room list\n";
		cout << "\t c: change library type\n";
		cout << "\t q: quit\n";
		cin >> c;
		cin.ignore();
		executeAction(c);
	} while (c != 'q');

	save("list.txt");

	list = NULL;

	return 0;
}

// Ask for details from user for the given selection and perform that action
// Read the function case by case
void executeAction(char c)
{
	string name_input;
	int no_input;
	int type_input = 2;
	libraryType type;
	Room* roomResult = NULL;

	switch (c)
	{
	case 'a':	// add room
				// input room details from user
		cout << endl << "Enter room name: ";
		getline(cin, name_input);
		cout << "Enter number of rooms: ";
		cin >> no_input;
		cin.ignore();

		while (!(type_input == 0 || type_input == 1))
		{
			cout << "Enter library type: " << endl;
			cout << "0. Hayden " << endl;
			cout << "1. Noble" << endl;
			cin >> type_input;
			cin.ignore();
		}
		type = (libraryType)type_input;

		// searchRoom() will return the room object if found, else returns NULL
		roomResult = searchRoom(name_input);
		if (roomResult == NULL)
		{
			addRoom(name_input, no_input, type);
			cout << endl << "Room added to list!" << endl << endl;
		}
		else
			cout << endl << "Room already present in the list!" << endl << endl;

		break;

	case 'd':		// display the list
		displayList();
		break;

	case 'c':		// change room type
		cout << endl << "Enter room name: ";
		getline(cin, name_input);
		// searchRoom() will return the room node if found, else returns NULL
		roomResult = searchRoom(name_input);
		if (roomResult == NULL)
		{
			cout << endl << "Room not in list!" << endl << endl;
		}
		else
		{
			// if room exists in the list, then ask user for new number of rooms
			cout << endl << "Enter new library type: "<<endl;
                        cout << "0. Hayden " << endl;
                        cout << "1. Noble" << endl;
			cin >> type_input;
			cin.ignore();
			type = (libraryType)type_input;
			// Q3c Call changeLibraryType() here   (1 point)
			// 'roomResult' contains the room whose Library Type is to be changed.
			// Call the function with appropriate arguments.

			changeLibraryType(roomResult, type);

			cout << endl << "Library type changed!" << endl << endl;
		}
		break;

	case 'q':		// quit
		break;

	default: cout << c << " is invalid input!\n";
	}

}

// No implementation needed here, however it may be helpful to review this function
Room* searchRoom(string name_input)
{

	Container* tempList = list;			// work on a copy of 'list'

	while (tempList != NULL)			// parse till end of list
	{
		if (tempList->room->getName() == name_input)
		{
			return tempList->room;	// return the room if found
		}

		tempList = tempList->next;		// parse the list
	}

	return NULL;						// return NULL if room not found in list
}

// Q3b: Define Friend Function changeLibraryType()  (3 points)
// Define the function changeLibraryType()that is declared in room.h file.
// This function sets the new library type for the room. The room object and new library type (as integer) are to be passed as function arguments.
// Use 'd' display option after using 'c' option to verify.
// You will need to implement add() and displayList() before you test this function.

void changeLibraryType(Room* room, int newLibraryType)
{
	// Checks if room is valid
	if (room)
	{
		Container* tempList = list;

		while (tempList != NULL)
		{
			if (tempList->room == room)
			{
				Room* tempRoom = nullptr;

				if (newLibraryType == 0)
				{
					tempRoom = new Hayden(room->getName(), room->getNo(), hayden);
				} else if (newLibraryType == 1)
				{
					tempRoom = new Noble(room->getName(), room->getNo(), noble);
				}

				

				// IDK anymore, I hope they switch after this.
				
				delete tempList->room;
				tempList->room = tempRoom;

				return;
			}

			tempList = tempList->next;
			
		}
		
		//cout << room->getName() << "'s library type is now: " << newLibraryType << endl;
		
	} //else { cout << "There is no room with that name" << endl; }   
}


// Q4: addRoom  (7 points)
// This function is used to add a new room to the global linked list 'list'. You may add the new room to head or tail of the list. (Sample solution adds to tail)
// libraryType 'type' can be hayden or noble. You will need to use the function argument 'type' to determine which constructor to use to create new room node.
// For example, if the user enters type as 'noble', then you need to use Noble class and constructor to create new room node and add it to the list.
// NOTE: In executeAction(), searchroom() is called before this function. Therefore no need to check here if the room exists in the list.
//       See how this fucntion is called in case 'a' of executeAction()

void addRoom(string name_input, int no_input, libraryType type) 
{
	Container* tempList = list;
	Container* newNode = new Container();

	if (type == hayden)
	{
		newNode->room = new Hayden(name_input, no_input, type);
	} else if (type == noble)
	{
		newNode->room = new Noble(name_input, no_input, type);
	}

	newNode->next = NULL;

	if (list == NULL)
	{
		list = newNode;
	} else
	{
		while (tempList->next!= NULL)
            tempList = tempList->next;
        tempList->next = newNode;
	}
	
}

// Q5: displayList	(4 points)
// This function displays the list of room and their details (name, no, library name)
// Parse the list and use the class member function to display the room info.
// See expected output in the question file.

void displayList()
{
	Container *tempList = list;			// work on a copy of 'list'

	while (tempList != NULL)
	{
		tempList->room->displayRoom();
		tempList = tempList->next;
	}
	
}

// Q6: save  (7 points)
// Save the linked list of rooms to a file list.txt using ofstream.
// You will need to save the number of rooms in linked list. That will help in load() when reading the file.
// One format to store is:
// <no. of rooms>
// <Room1 name>
// <Room1 no>
// <Room type>
// <Room2 name>
// <Room2 no>
// <Room2 type>
// and so on..
// You may store the list in another format if you wish. You need to read the file in load () the same way that it is saved in save().
// This function is called when exiting the program (end of main() ).
// Hint: You may want to cast the enum 'libraryType' to an int before writing it to the file.


void save(string fileName)
{
	ofstream outputFile;
	outputFile.open(fileName);

	if (outputFile.is_open())
	{
		Container* tempList = list;
		int count = 0;

		while (tempList != nullptr)
		{
			count++;
			tempList = tempList->next;
		}

		outputFile << count;

        tempList = list;

        while (tempList!= NULL)
        {
	        outputFile << tempList->room->getName() << endl;
            outputFile << tempList->room->getNo() << endl;
            outputFile << static_cast<int>(tempList->room->getLibraryType()) << endl; // Static Cast: Converts the libType to an integer value
            tempList = tempList->next;
        }

		outputFile.close();
		cout << "List saved to " << fileName << endl;
		
	} else
	{
		cout << "Unable to located/save file" << endl;
	}
	
}

// Q7: load (7 points)
// Load the linked list of rooms from the file using ifstream.
// You will need to create the linked list in the same order that is was saved to the file in save().
// First, read the number of rooms saved in the file.
// Then, for every room you will need to create a new Room node depending on room type. You may add the room to head or tail of the list. 
// Hint: If you casted the enum 'libraryType' to an int, you will need to cast it back to 'libraryType' when making the room node.
// This function is called at the beginning of main().

void load(string fileName)
{
	ifstream inputFile;
	inputFile.open(fileName);

	if (inputFile.is_open())
	{
		int count;
		inputFile >> count;

		for (int i = 0; i < count; i++)
		{
			
			
			string name;
			int no;
			int libTypeInt;

			getline(inputFile, name);

			//inputFile.ignore();
			
			

			inputFile >> no;
			inputFile >> libTypeInt;


			inputFile.ignore();
			
			
			libraryType libType = static_cast<libraryType>(libTypeInt); // Static Cast: Converts the int back into the libType

			if (libType == hayden)
			{
				addRoom(name, no, hayden);
			} else if (libType == noble)
			{
				addRoom(name, no, noble);
			}

			// Debug Code: My code did not want to load the names, (solution: inputFile.ignore() location was in the wrong location)
			//cout << "Room loaded: " << name << ", No: " << no << ", Library: " << (libType == hayden? "Hayden" : "Noble") << endl; 
			
		}

		inputFile.close();
	}
	
}
